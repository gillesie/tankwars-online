<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artillery Blitz: Campaign Edition</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0; overflow: hidden; background-color: #050510;
            color: #fff; font-family: 'Orbitron', sans-serif;
            user-select: none; cursor: crosshair;
        }
        canvas { display: block; }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top {
            display: flex; justify-content: space-between; align-items: flex-start;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7); width: 100%;
        }

        .stat-box {
            background: rgba(0, 20, 40, 0.8); border: 1px solid #0ff;
            padding: 10px 20px; border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2); min-width: 150px;
        }
        .team-1-hud { border-color: #0ff; }
        .team-2-hud { border-color: #f00; }

        .stat-label { font-size: 12px; color: #aaa; letter-spacing: 1px; display: block; margin-bottom: 5px; }
        .stat-value { font-size: 20px; font-weight: 700; color: #fff; }
        .bar-container { width: 100%; height: 8px; background: #111; margin-top: 5px; border-radius: 2px; overflow: hidden; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.2s; }
        .hp-fill { background: linear-gradient(90deg, #f00, #f0f); }
        .shield-fill { background: linear-gradient(90deg, #ff0, #fff); width: 0%; }
        .power-fill { background: linear-gradient(90deg, #0ff, #fff); }

        .weapon-selector { text-align: right; pointer-events: auto; min-width: 280px; }
        .weapon-grid { display: flex; gap: 5px; justify-content: flex-end; margin-top: 5px; }
        .weapon-btn {
            width: 50px; height: 50px; border: 1px solid #055; background: rgba(0, 0, 0, 0.5);
            color: #0aa; font-size: 10px; display: flex; flex-direction: column;
            align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s;
        }
        .weapon-btn:hover { background: #033; border-color: #0ff; color: #fff; }
        .weapon-btn.active { background: #0aa; color: #000; border-color: #fff; box-shadow: 0 0 15px #0ff; font-weight: bold; }
        .weapon-btn.locked { opacity: 0.3; pointer-events: none; filter: grayscale(1); border-color: #333; }
        .weapon-btn.builder { border-color: #f0f; color: #f0f; }
        .weapon-btn.builder.active { background: #f0f; box-shadow: 0 0 15px #f0f; }
        .w-icon { font-size: 16px; margin-bottom: 2px; }

        /* SCREENS */
        #start-screen, #game-over-screen, #mp-lobby-screen, #level-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.92); display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10; backdrop-filter: blur(10px);
        }

        h1 { font-size: 64px; margin: 0; background: -webkit-linear-gradient(#0ff, #f0f); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 30px rgba(0,255,255,0.5); }
        h2 { font-size: 32px; color: #fff; margin-bottom: 30px; }
        .credits { color: #f0f; font-size: 14px; margin-top: -10px; margin-bottom: 40px; letter-spacing: 2px; }

        .btn-group { display: flex; gap: 40px; margin-top: 20px; }
        button {
            background: transparent; border: 2px solid #0ff; color: #0ff;
            padding: 20px 50px; font-size: 20px; font-family: 'Orbitron', sans-serif;
            cursor: pointer; transition: all 0.3s; text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        button:hover { background: #0ff; color: #000; box-shadow: 0 0 40px rgba(0, 255, 255, 0.8); transform: scale(1.05); }
        button.secondary { border-color: #f0f; color: #f0f; }
        button.secondary:hover { background: #f0f; color: #000; box-shadow: 0 0 40px rgba(255, 0, 255, 0.8); }
        
        /* SP HUD EXTRAS */
        #sp-timer-box { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); text-align: center; display: none; }
        .timer-val { font-size: 40px; font-weight: 900; color: #f00; text-shadow: 0 0 10px #f00; }
        
        .hidden { display: none !important; }
        
        #power-overlay {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); width: 200px; text-align: center;
        }
        #minimap-container {
            position: absolute; bottom: 20px; right: 20px; width: 300px; height: 180px;
            background: rgba(0, 10, 20, 0.9); border: 2px solid #0ff; z-index: 5;
        }
        #minimapCanvas { width: 100%; height: 100%; display: block; }
        
        #battle-log {
            position: absolute; bottom: 20px; left: 20px; width: 300px; height: 150px;
            pointer-events: none; overflow: hidden; display: flex; flex-direction: column; justify-content: flex-end;
            font-size: 12px; text-shadow: 1px 1px 0 #000;
        }
        .log-entry { margin-top: 4px; opacity: 0.8; }

        /* LOBBY STYLES */
        .lobby-container { display: flex; flex-direction: column; gap: 15px; width: 100%; max-width: 600px; }
        .lobby-input { background: rgba(0,0,0,0.8); border: 1px solid #0ff; color: #fff; padding: 15px; font-family: 'Orbitron'; font-size: 18px; width: 100%; box-sizing: border-box; }
        .room-list { margin-top: 20px; max-height: 300px; overflow-y: auto; border: 1px solid #055; background: rgba(0,20,40,0.5); padding: 10px; }
        .room-item { display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #033; cursor: pointer; }
        .room-item:hover { background: #003344; }

        #scoreboard {
            position: absolute; top: 160px; right: 20px; width: 200px;
            background: rgba(0,0,0,0.7); border: 1px solid #0ff; padding: 10px;
            pointer-events: none; display: none;
        }
        .sb-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px; }
        .sb-header { font-weight: bold; border-bottom: 1px solid #555; margin-bottom: 5px; }
        .sb-blue { color: #0ff; } .sb-red { color: #f33; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box" id="hp-box">
                <span class="stat-label">ARMOR INTEGRITY</span>
                <div class="bar-container"><div class="bar-fill hp-fill" id="hud-hp"></div></div>
                <span class="stat-value" id="hud-hp-text">100%</span>
                <div class="bar-container" style="height: 4px; margin-top: 2px;"><div class="bar-fill shield-fill" id="hud-shield"></div></div>
            </div>

            <div class="stat-box" style="text-align: center;">
                <span class="stat-label" id="level-label">MISSION STATUS</span>
                <span class="stat-value" id="hud-level" style="font-size: 24px;">READY</span>
                <div style="color: #ff0; font-weight: bold; margin-top: 5px;">LIVES: <span id="hud-lives">3</span></div>
            </div>

            <div class="stat-box weapon-selector">
                <span class="stat-label">WEAPON SYSTEMS</span>
                <div class="weapon-grid">
                    <div class="weapon-btn active" id="btn-standard" onclick="selectWeapon('standard')"><span class="w-icon">●</span><span>STD</span><span id="ammo-standard">50</span></div>
                    <div class="weapon-btn" id="btn-scatter" onclick="selectWeapon('scatter')"><span class="w-icon">⁙</span><span>SCTR</span><span id="ammo-scatter">0</span></div>
                    <div class="weapon-btn" id="btn-laser" onclick="selectWeapon('laser')"><span class="w-icon">━</span><span>LASR</span><span id="ammo-laser">0</span></div>
                    <div class="weapon-btn" id="btn-seeker" onclick="selectWeapon('seeker')"><span class="w-icon">◎</span><span>SEEK</span><span id="ammo-seeker">0</span></div>
                    <div class="weapon-btn" id="btn-nuke" onclick="selectWeapon('nuke')"><span class="w-icon">☢</span><span>NUKE</span><span id="ammo-nuke">0</span></div>
                    <div class="weapon-btn builder locked" id="btn-builder" onclick="selectWeapon('builder')"><span class="w-icon">⚒</span><span>BUILD</span><span id="ammo-builder">∞</span></div>
                </div>
            </div>
        </div>

        <div id="sp-timer-box">
            <span class="stat-label">TIME REMAINING</span>
            <div class="timer-val" id="hud-timer">00:00</div>
        </div>

        <div id="power-overlay">
            <span class="stat-label">SHOT POWER</span>
            <div class="bar-container"><div class="bar-fill power-fill" id="hud-power" style="width: 0%;"></div></div>
        </div>

        <div id="battle-log"></div>

        <div id="minimap-container">
            <canvas id="minimapCanvas"></canvas>
        </div>
        
        <div id="scoreboard">
            <div class="sb-header">BLUE TEAM <span id="sb-count-1">0</span></div>
            <div id="sb-list-1"></div>
            <div class="sb-header" style="margin-top:10px; color: #f33;">RED TEAM <span id="sb-count-2">0</span></div>
            <div id="sb-list-2"></div>
        </div>
    </div>

    <div id="start-screen">
        <h1>NEON BLITZ</h1>
        <div class="credits">GAME DEVELOPED BY @GILLESIE</div>
        <h2>SELECT OPERATION MODE</h2>
        
        <div class="btn-group">
            <button class="secondary" onclick="startSinglePlayerSetup()">SINGLE PLAYER</button>
            <button onclick="showMultiplayerLobby()">MULTIPLAYER PVP</button>
        </div>
        
        <p style="margin-top: 40px; font-size: 12px;">
            CONTROLS: [A/D] Move • [SPACE] Jump (Hold) • [MOUSE] Aim/Fire • [SCROLL] Zoom
        </p>
    </div>

    <div id="level-screen" class="hidden">
        <h1 id="lvl-title">LEVEL 1</h1>
        <h2 id="lvl-objective">DESTROY ALL HOSTILES</h2>
        <div id="lvl-rewards" style="color: #0ff; margin-bottom: 20px;"></div>
        <button onclick="SPManager.startLevel()">INITIATE</button>
    </div>

    <div id="mp-lobby-screen" class="hidden">
        <h1>GLOBAL LOBBY</h1>
        <button onclick="location.reload()" style="position: absolute; top: 20px; left: 20px; border:none; font-size:12px;">&lt; BACK</button>
        
        <div id="join-area" class="lobby-container">
            <input id="inp-name" class="lobby-input" type="text" placeholder="PILOT NAME" maxlength="12">
            <input id="inp-room" class="lobby-input" type="text" placeholder="ROOM CODE (e.g. WARZONE)" maxlength="10">
            
            <div style="display:flex; gap:10px;">
                <button id="btn-team-1" style="flex:1; border-color:#0ff; color:#0ff;" onclick="setTeam(1)">BLUE</button>
                <button id="btn-team-2" style="flex:1; border-color:#f00; color:#f00;" onclick="setTeam(2)">RED</button>
            </div>

            <button onclick="joinGame()" style="margin-top: 10px; width: 100%;">CONNECT</button>
            <div id="room-list-container" class="room-list">Waiting for server...</div>
        </div>

        <div id="waiting-area" class="hidden">
            <h2>DEPLOYMENT STANDBY</h2>
            <div id="waiting-player-list">Waiting for pilots...</div>
            <button id="btn-start-game" class="hidden" onclick="requestStart()" style="border-color: #0f0; color: #0f0;">INITIATE BATTLE</button>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 id="go-title" style="-webkit-text-fill-color: #f00;">MISSION TERMINATED</h1>
        <h2 id="go-score"></h2>
        <button onclick="location.reload()">RETURN TO BASE</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        /* --- CONFIG & GLOBALS --- */
        let mode = 'menu'; // menu, sp, mp
        let socket;
        let isMultiplayer = false;
        
        // Physics
        const GRAVITY = 0.4;
        const TERRAIN_WIDTH = 6000;
        const SEGMENT_SIZE = 20;
        const WORLD_HEIGHT = 1500;
        let wind = 0;

        // Game Objects
        let player;
        let projectiles = [];
        let particles = [];
        let floatingTexts = [];
        let crates = [];
        let platforms = [];
        let terrainPoints = [];
        let remotePlayers = {}; // For MP
        let bots = []; // For SP

        // Inputs & Camera
        const camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
        let mousePos = { x: 0, y: 0 };
        const keys = {};
        let isCharging = false;
        let mousePressedTime = 0;
        let isDrawing = false;
        let drawStart = { x: 0, y: 0 };
        let screenShake = 0;

        /* --- SINGLE PLAYER MANAGER --- */
        const SPManager = {
            level: 1,
            timeLeft: 0,
            timerInterval: null,
            isActive: false,
            
            levels: {
                get(lvl) {
                    const difficulty = Math.min(lvl, 20);
                    const isBoss = lvl % 5 === 0;
                    return {
                        enemyCount: isBoss ? 1 : Math.ceil(lvl * 1.5),
                        enemyHp: isBoss ? 500 + (lvl*50) : 60 + (lvl * 10),
                        isBoss: isBoss,
                        timeLimit: isBoss ? 300 : 120, // seconds
                        unlocked: this.getUnlocks(lvl),
                        ammoDrops: 3 + Math.floor(lvl/2)
                    };
                },
                getUnlocks(lvl) {
                    const unlocks = ['standard'];
                    if(lvl >= 3) unlocks.push('scatter');
                    if(lvl >= 5) unlocks.push('laser');
                    if(lvl >= 7) unlocks.push('seeker');
                    if(lvl >= 10) unlocks.push('nuke');
                    if(lvl >= 12) unlocks.push('builder');
                    return unlocks;
                }
            },

            init() {
                mode = 'sp';
                isMultiplayer = false;
                this.level = 1;
                player = new Tank(true, 1, 'player');
                player.name = "COMMANDER";
                player.lives = 3;
                // Reset ammo logic for SP
                player.ammo = { 'standard': 30, 'scatter': 0, 'laser': 0, 'seeker': 0, 'nuke': 0, 'builder': Infinity };
                this.showLevelScreen();
            },

            showLevelScreen() {
                this.isActive = false;
                const config = this.levels.get(this.level);
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('game-over-screen').classList.add('hidden');
                document.getElementById('ui-layer').classList.add('hidden');
                
                const screen = document.getElementById('level-screen');
                screen.classList.remove('hidden');
                document.getElementById('lvl-title').innerText = config.isBoss ? `WARNING: BOSS LEVEL ${this.level}` : `LEVEL ${this.level}`;
                document.getElementById('lvl-objective').innerText = config.isBoss ? "DEFEAT THE JUGGERNAUT" : "ELIMINATE ALL HOSTILES";
                document.getElementById('lvl-title').style.webkitTextFillColor = config.isBoss ? '#f00' : 'transparent';
                
                let rewards = "INTEL: Enemies stronger. ";
                if(this.level === 3) rewards += "WEAPON UNLOCK: SCATTER. ";
                if(this.level === 5) rewards += "WEAPON UNLOCK: LASER. ";
                if(this.level === 12) rewards += "TOOL UNLOCK: BUILDER. ";
                document.getElementById('lvl-rewards').innerText = rewards;
            },

            startLevel() {
                document.getElementById('level-screen').classList.add('hidden');
                document.getElementById('ui-layer').classList.remove('hidden');
                document.getElementById('sp-timer-box').style.display = 'block';
                document.getElementById('hud-level').innerText = "LEVEL " + this.level;
                
                // Unlock check
                const unlocks = this.levels.getUnlocks(this.level);
                ['scatter', 'laser', 'seeker', 'nuke', 'builder'].forEach(w => {
                    const btn = document.getElementById('btn-'+w);
                    if(unlocks.includes(w)) btn.classList.remove('locked');
                    else btn.classList.add('locked');
                });

                this.generateWorld();
                this.spawnEnemies();
                this.spawnCrates();
                
                player.x = 200; player.y = -500; player.vx = 0; player.vy = 0;
                player.hp = player.maxHp; // Heal between levels
                
                this.timeLeft = this.levels.get(this.level).timeLimit;
                this.isActive = true;
                
                clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    if(!this.isActive || player.dead) return;
                    this.timeLeft--;
                    const mins = Math.floor(this.timeLeft / 60);
                    const secs = this.timeLeft % 60;
                    document.getElementById('hud-timer').innerText = `${mins}:${secs<10?'0':''}${secs}`;
                    
                    if(this.timeLeft <= 0) {
                        player.takeDamage(9999);
                        log("TIME EXPIRED. MISSION FAILED.");
                    }
                }, 1000);
            },

            generateWorld() {
                generateTerrain();
                platforms = [];
                // Generate some platforms
                const count = 10 + Math.floor(this.level);
                let cx = 500;
                for(let i=0; i<count; i++) {
                    platforms.push({
                        id: 'sp_plat_'+i,
                        x: cx + Math.random()*400,
                        y: getTerrainHeight(cx) - 100 - Math.random()*300,
                        width: 100 + Math.random()*200,
                        height: 20,
                        angle: Math.random()*20 - 10,
                        hp: 500, maxHp: 500, type: 'standard'
                    });
                    cx += 400;
                    if(cx > TERRAIN_WIDTH - 500) break;
                }
            },

            spawnEnemies() {
                bots = [];
                const config = this.levels.get(this.level);
                
                if (config.isBoss) {
                    const boss = new Tank(false, 2, 'BOSS');
                    boss.x = TERRAIN_WIDTH - 400;
                    boss.maxHp = config.enemyHp;
                    boss.hp = config.enemyHp;
                    boss.name = "JUGGERNAUT";
                    boss.isBoss = true;
                    boss.ai = new BotAI(boss, 10); // High skill
                    boss.ammo['nuke'] = Infinity; // Uh oh
                    bots.push(boss);
                } else {
                    for(let i=0; i<config.enemyCount; i++) {
                        const bot = new Tank(false, 2, `bot_${i}`);
                        bot.x = 1000 + Math.random() * (TERRAIN_WIDTH - 1500);
                        bot.y = -500;
                        bot.maxHp = config.enemyHp;
                        bot.hp = config.enemyHp;
                        bot.name = `DRONE MK.${this.level}`;
                        bot.ai = new BotAI(bot, Math.min(this.level, 8));
                        bots.push(bot);
                    }
                }
            },

            spawnCrates() {
                crates = [];
                const count = this.levels.get(this.level).ammoDrops;
                for(let i=0; i<count; i++) {
                    // Mostly ammo in SP
                    let type = Math.random() > 0.7 ? 'repair' : 'ammo'; 
                    // Chance for better weapons
                    if(Math.random() > 0.9) type = 'nuke';
                    crates.push(new Crate('crate_'+i, Math.random() * (TERRAIN_WIDTH-200) + 100, -500, type));
                }
            },

            checkWin() {
                if(!this.isActive) return;
                const aliveBots = bots.filter(b => !b.dead);
                if(aliveBots.length === 0) {
                    this.isActive = false;
                    clearInterval(this.timerInterval);
                    log("SECTOR CLEARED. PROCEEDING...");
                    setTimeout(() => {
                        this.level++;
                        this.showLevelScreen();
                    }, 2000);
                }
            }
        };

        /* --- BOT AI --- */
        class BotAI {
            constructor(tank, difficulty) {
                this.tank = tank;
                this.difficulty = difficulty; // 1-10
                this.nextActionTime = Date.now() + 2000;
                this.moveTimer = 0;
            }

            update() {
                if(this.tank.dead || player.dead) return;

                // Aiming
                const dx = player.x - this.tank.x;
                const dy = (player.y - 20) - (this.tank.y - 20);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                // Error based on difficulty
                const error = (10 - this.difficulty) * 2; 
                this.tank.turretAngle += (angle - this.tank.turretAngle) * 0.1;

                // Firing
                if(Date.now() > this.nextActionTime) {
                    // Check Line of Sight (Simple distance check for now)
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist < 1500) {
                        // Calculate Power roughly
                        let power = dist / 40; 
                        power += (Math.random() * error) - (error/2); // Aim error
                        power = Math.min(Math.max(power, 5), 25);
                        
                        // Boss uses nukes sometimes
                        if(this.tank.isBoss && Math.random() < 0.3) this.tank.currentWeapon = 'nuke';
                        else this.tank.currentWeapon = 'standard';
                        
                        this.tank.fire(power);
                        this.nextActionTime = Date.now() + 2000 + (Math.random() * 2000);
                    }
                }
            }
        }

        /* --- CLASSES --- */
        class Tank {
            constructor(isLocal, team, id) {
                this.id = id;
                this.isLocal = isLocal;
                this.team = team;
                this.x = isLocal ? 200 : 0;
                this.y = -500;
                this.vx = 0; this.vy = 0;
                this.angle = 0; this.turretAngle = team === 1 ? 315 : 225;
                this.hp = 100; this.maxHp = 100;
                this.shield = 0;
                this.lives = 3;
                this.name = "UNIT";
                this.dead = false;
                this.isBoss = false;
                
                // Finite ammo for everyone in SP
                this.ammo = { 'standard': 50, 'scatter': 0, 'laser': 0, 'nuke': 0, 'seeker': 0, 'builder': 0 };
                this.currentWeapon = 'standard';
                this.onGround = false;
                this.groundStartHeight = 0;
                this.hitFlashTimer = 0;
            }

            update() {
                if (this.dead) return;
                
                // AI Update
                if(this.ai) this.ai.update();

                // Physics (Run for Local Player AND Bots in SP, only Local in MP)
                if (this.isLocal || (!isMultiplayer && this.ai)) {
                    // Movement
                    if(this.isLocal && mode !== 'menu') {
                        this.vx = 0;
                        if (keys['ArrowLeft'] || keys['a']) this.vx = -4;
                        if (keys['ArrowRight'] || keys['d']) this.vx = 4;
                        if ((keys['ArrowUp'] || keys[' '] || keys['Space'])) {
                            if (this.onGround) {
                                this.vy = JUMP_FORCE; this.onGround = false;
                                this.groundStartHeight = this.y;
                            } else if (this.vy < 0 && Math.abs(this.y - this.groundStartHeight) < 200) {
                                this.vy += JUMP_SUSTAIN;
                            }
                        }
                        const tx = mousePos.x / camera.zoom + camera.x;
                        const ty = mousePos.y / camera.zoom + camera.y;
                        this.turretAngle = Math.atan2(ty - (this.y - 10), tx - this.x) * 180 / Math.PI;
                        
                        if(isMultiplayer && socket) {
                            socket.emit('updateState', { x: this.x, y: this.y, angle: this.angle, turretAngle: this.turretAngle, hp: this.hp, shield: this.shield });
                        }
                    }

                    this.vy += GRAVITY;
                    this.x += this.vx; this.y += this.vy;
                    this.handleCollisions();
                } else if (isMultiplayer) {
                    // Remote Interpolation
                    this.x += (this.targetX - this.x || 0) * 0.2;
                    this.y += (this.targetY - this.y || 0) * 0.2;
                }
            }

            handleCollisions() {
                this.x = Math.max(20, Math.min(this.x, TERRAIN_WIDTH - 20));
                this.onGround = false;
                const floorY = getTerrainHeight(this.x);
                if (this.y >= floorY - 10) {
                    this.y = floorY - 10; this.vy = 0; this.onGround = true;
                    this.groundStartHeight = this.y;
                    this.angle = Math.atan2(getTerrainHeight(this.x+10)-getTerrainHeight(this.x-10), 20);
                }
                platforms.forEach(p => {
                    if (this.x > p.x && this.x < p.x + p.width && this.vy >= 0) {
                        const rad = p.angle * (Math.PI/180);
                        const py = p.y + ((this.x - p.x) * Math.tan(rad));
                        if (this.y > py - 25 && this.y < py + 10) {
                            this.y = py - 10; this.vy = 0; this.onGround = true;
                            this.groundStartHeight = this.y;
                            this.angle = rad;
                        }
                    }
                });
            }

            fire(power) {
                if(this.currentWeapon === 'builder') return;
                
                // Ammo Check (SP only mostly, MP server handles authority usually but we check locally too)
                if (this.ammo[this.currentWeapon] <= 0 && this.currentWeapon !== 'standard') {
                    this.currentWeapon = 'standard';
                }
                
                // Hard check for NO INFINITE AMMO ever in SP
                if (!isMultiplayer && this.ammo[this.currentWeapon] <= 0) {
                     // Empty click
                     log("AMMO DEPLETED!");
                     return;
                }

                if (!isMultiplayer && !this.ai) this.ammo[this.currentWeapon]--;
                
                const rad = this.turretAngle * (Math.PI / 180);
                const bx = this.x + Math.cos(rad) * 20;
                const by = (this.y - 15) + Math.sin(rad) * 20;

                if (isMultiplayer && this.isLocal) {
                    socket.emit('fire', { x: bx, y: by, angle: this.turretAngle, power: power, type: this.currentWeapon });
                }

                const p = new Projectile(bx, by, this.turretAngle, power, this.team, this.currentWeapon);
                projectiles.push(p);
                screenShake = 5;
                updateHUD();
            }
            
            takeDamage(amount) {
                if(this.dead) return;
                floatingTexts.push(new FloatingText(this.x, this.y - 30, "-" + Math.ceil(amount), '#f00', 14));
                this.hitFlashTimer = 10;
                
                if (this.shield > 0) {
                    this.shield -= amount;
                    if (this.shield < 0) { this.hp += this.shield; this.shield = 0; }
                } else {
                    this.hp -= amount;
                }

                if (this.hp <= 0) {
                    this.hp = 0;
                    this.dead = true;
                    createExplosion(this.x, this.y, 'nuke');
                    
                    if (isMultiplayer && this.isLocal) {
                        socket.emit('died');
                    } else if (!isMultiplayer) {
                        // Single Player Death Logic
                        if (this.isLocal) {
                            this.lives--;
                            if(this.lives > 0) {
                                log(`UNIT LOST. RESPAWNING... (${this.lives} REMAINING)`);
                                setTimeout(() => {
                                    this.dead = false; this.hp = 100; 
                                    this.x = 200; this.y = -500;
                                    // Give some pity ammo
                                    this.ammo.standard = Math.max(this.ammo.standard, 30);
                                }, 3000);
                            } else {
                                setTimeout(() => {
                                    document.getElementById('game-over-screen').classList.remove('hidden');
                                    document.getElementById('go-title').innerText = "M.I.A.";
                                    document.getElementById('go-score').innerText = `REACHED LEVEL ${SPManager.level}`;
                                }, 2000);
                            }
                        } else {
                            // Bot died
                             SPManager.checkWin();
                        }
                    }
                }
                updateHUD();
            }

            draw(ctx) {
                if(this.dead) return;
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                if (this.hitFlashTimer > 0) { this.hitFlashTimer--; ctx.globalCompositeOperation = 'lighter'; }
                
                const color = this.team === 1 ? '#0ff' : '#f00';
                
                // Boss Scale
                if(this.isBoss) ctx.scale(2, 2);

                ctx.shadowBlur = 10; ctx.shadowColor = color; ctx.strokeStyle = color; ctx.fillStyle = '#000'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(15, 0); ctx.lineTo(10, -15); ctx.lineTo(-10, -15); ctx.fill(); ctx.stroke();
                
                if(!this.isLocal && !this.isBoss) {
                    ctx.fillStyle = color; ctx.font = "10px Orbitron"; ctx.textAlign = "center"; ctx.fillText(this.name, 0, -30);
                }
                if(this.isBoss) {
                    ctx.fillStyle = '#f00'; ctx.font = "bold 8px Orbitron"; ctx.textAlign = "center"; ctx.fillText("BOSS", 0, -20);
                }

                ctx.restore();
                ctx.save(); ctx.translate(this.x, this.y-7); ctx.rotate(this.turretAngle*Math.PI/180);
                if(this.isBoss) ctx.scale(2,2);
                ctx.fillStyle = color; ctx.fillRect(0, -3, 30, 6);
                ctx.restore();

                // HP Bar
                ctx.fillStyle = '#f00'; ctx.fillRect(this.x-20, this.y-50, 40, 4);
                ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-20, this.y-50, 40*(this.hp/this.maxHp), 4);
            }
        }
        
        class Projectile {
            constructor(x, y, angle, power, team, type) {
                this.x = x; this.y = y; this.type = type; this.team = team;
                const rad = angle * (Math.PI / 180);
                this.vx = Math.cos(rad) * power; this.vy = Math.sin(rad) * power;
                if (type === 'laser') { this.vx*=2; this.vy*=2; }
                if (type === 'seeker') { this.vx*=0.5; this.vy*=0.5; }
                this.active = true; this.trail = []; this.age = 0;
            }
            update() {
                if(!this.active) return;
                this.age++;
                
                if (this.type === 'seeker') {
                    // Find Target (Player if bot, Bot if player)
                    let target = null;
                    if (this.team === 2 && !player.dead) target = player;
                    else if (this.team === 1) {
                        let minD = 2000;
                        bots.forEach(b => { if(!b.dead && dist(this.x,this.y,b.x,b.y)<minD) { minD=dist(this.x,this.y,b.x,b.y); target=b; }});
                    }
                    if (target) {
                         const desired = Math.atan2((target.y-10)-this.y, target.x-this.x);
                         const curr = Math.atan2(this.vy, this.vx);
                         let diff = desired - curr;
                         while(diff < -Math.PI) diff += Math.PI*2; while(diff > Math.PI) diff -= Math.PI*2;
                         const speed = Math.sqrt(this.vx**2 + this.vy**2);
                         const newAng = curr + Math.max(-0.1, Math.min(0.1, diff));
                         this.vx = Math.cos(newAng)*speed; this.vy = Math.sin(newAng)*speed;
                    }
                } else if(this.type !== 'laser') this.vy += GRAVITY;

                if (this.type !== 'seeker') this.vx += wind;
                
                // Movement Steps
                const speed = Math.sqrt(this.vx**2 + this.vy**2);
                const steps = Math.ceil(speed/5);
                for(let i=0; i<steps; i++) {
                    this.x += this.vx/steps; this.y += this.vy/steps;
                    if(this.y >= getTerrainHeight(this.x)) { this.explode(); return; }
                    
                    // Platform collision
                    if(this.age > 5) {
                        platforms.forEach(p => {
                            if(this.x > p.x && this.x < p.x+p.width && Math.abs(this.y - p.y) < 20) {
                                this.explode();
                                // Destroy platform logic in SP
                                if(!isMultiplayer && p.type !== 'unbreakable') {
                                    p.hp -= (this.type==='nuke'?100:25);
                                    if(p.hp<=0) {
                                        platforms = platforms.filter(pl => pl !== p);
                                        createExplosion(p.x+p.width/2, p.y, 'standard');
                                    }
                                }
                            }
                        });
                        if(!this.active) return;
                    }

                    // Entity Collision
                    const targets = isMultiplayer ? [player, ...Object.values(remotePlayers)] : [player, ...bots];
                    targets.forEach(t => {
                        if(t.team !== this.team && !t.dead && dist(this.x, this.y, t.x, t.y) < 25) {
                            this.explode();
                        }
                    });
                    if(!this.active) return;
                }
                this.trail.push({x:this.x, y:this.y});
                if(this.trail.length > 10) this.trail.shift();
            }
            explode() {
                this.active = false;
                createExplosion(this.x, this.y, this.type);
                const radius = this.type==='nuke' ? 300 : (this.type==='cluster'?100:80);
                const dmg = this.type==='nuke' ? 100 : (this.type==='laser'?30:20);
                
                const targets = isMultiplayer ? [player, ...Object.values(remotePlayers)] : [player, ...bots];
                targets.forEach(t => {
                    if (!t.dead && dist(this.x, this.y, t.x, t.y) < radius) {
                        if (isMultiplayer) {
                            // Only local player calculates their own damage in MP usually, 
                            // but for simplicity, we let the firer calculate damage confirm in SP
                        }
                        if (!isMultiplayer) t.takeDamage(dmg);
                        else if (t === player) {
                            t.takeDamage(dmg); 
                            socket.emit('hit', { damage: dmg, x: t.x, y: t.y });
                        }
                    }
                });
            }
            draw(ctx) {
                if(!this.active) return;
                ctx.beginPath(); ctx.moveTo(this.trail[0]?.x||this.x, this.trail[0]?.y||this.y);
                this.trail.forEach(t=>ctx.lineTo(t.x,t.y));
                ctx.strokeStyle = this.type==='nuke'?'#ff0':(this.team===1?'#0ff':'#f00');
                ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
            }
        }

        class Crate {
            constructor(id, x, y, type) { this.id = id; this.x = x; this.y = y; this.type = type; this.landed = false; }
            update() {
                if(!this.landed) {
                    this.y += 3;
                    if(this.y >= getTerrainHeight(this.x)-15) { this.y=getTerrainHeight(this.x)-15; this.landed=true; }
                }
                if(player && !player.dead && dist(this.x,this.y,player.x,player.y) < 40) {
                    this.collect();
                }
            }
            collect() {
                crates = crates.filter(c => c.id !== this.id);
                createExplosion(this.x, this.y, 'heal');
                if(isMultiplayer) socket.emit('crateCollected', this.id);
                
                log(`ACQUIRED: ${this.type.toUpperCase()}`);
                if(this.type === 'repair') player.hp = Math.min(player.maxHp, player.hp + 30);
                else if(this.type === 'shield') player.shield = 50;
                else if(this.type === 'ammo') {
                    // Universal ammo pack
                    player.ammo.standard += 50;
                    if(SPManager.levels.getUnlocks(SPManager.level).includes('scatter')) player.ammo.scatter += 10;
                    if(SPManager.levels.getUnlocks(SPManager.level).includes('seeker')) player.ammo.seeker += 5;
                } else {
                    // Specific weapon unlock/ammo
                    player.ammo[this.type] += (this.type==='nuke'?1:5);
                }
                updateHUD();
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = '#000'; ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2;
                ctx.fillRect(-10,-10,20,20); ctx.strokeRect(-10,-10,20,20);
                ctx.fillStyle = '#0f0'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
                ctx.fillText(this.type==='repair'?'+':(this.type==='nuke'?'☢':'?'), 0, 5);
                ctx.restore();
            }
        }
        
        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random()-0.5)*10; this.vy = (Math.random()-0.5)*10;
                this.life = 1.0;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; this.vy+=0.2; }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        class FloatingText {
            constructor(x, y, txt, col) { this.x=x; this.y=y; this.txt=txt; this.col=col; this.life=1.0; }
            update() { this.y-=1; this.life-=0.02; }
            draw(ctx) {
                if(this.life<=0)return;
                ctx.globalAlpha=this.life; ctx.fillStyle=this.col; ctx.font="bold 14px Orbitron";
                ctx.textAlign="center"; ctx.fillText(this.txt, this.x, this.y); ctx.globalAlpha=1;
            }
        }

        /* --- CORE FUNCTIONS --- */
        function init() {
            window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            
            canvas.addEventListener('mousemove', e => {
                const r = canvas.getBoundingClientRect();
                mousePos.x = e.clientX - r.left; mousePos.y = e.clientY - r.top;
            });
            
            canvas.addEventListener('mousedown', e => {
                if(mode==='menu') return;
                if(e.button===0 && player && !player.dead) {
                    if(player.currentWeapon==='builder') {
                        isDrawing = true;
                        drawStart = { x: mousePos.x/camera.zoom + camera.x, y: mousePos.y/camera.zoom + camera.y };
                    } else {
                        isCharging = true; mousePressedTime = Date.now();
                    }
                }
            });
            
            canvas.addEventListener('mouseup', e => {
                if(mode==='menu' || !player || player.dead) return;
                if(isDrawing) {
                    isDrawing = false;
                    const endX = mousePos.x/camera.zoom+camera.x; const endY = mousePos.y/camera.zoom+camera.y;
                    const dx = endX-drawStart.x; const dy = endY-drawStart.y;
                    const w = Math.sqrt(dx*dx+dy*dy);
                    if(w > 20) {
                         const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                         const p = { id: 'dyn_'+Math.random(), x: drawStart.x, y: drawStart.y, width: w, height: 20, angle: angle, hp: 200, maxHp: 200, type: 'standard' };
                         platforms.push(p);
                         if(isMultiplayer) socket.emit('createPlatform', p);
                    }
                } else if(isCharging) {
                    const dur = Date.now() - mousePressedTime;
                    let pwr = Math.min(dur/40, 25); pwr = Math.max(pwr, 2);
                    player.fire(pwr);
                    isCharging = false;
                    document.getElementById('hud-power').style.width = '0%';
                }
            });
            
            canvas.addEventListener('wheel', e => {
                camera.targetZoom = Math.max(0.5, Math.min(2.0, camera.targetZoom + (e.deltaY<0?0.05:-0.05)));
            });

            document.addEventListener('keydown', e => keys[e.key] = true);
            document.addEventListener('keyup', e => keys[e.key] = false);
            
            animate();
        }

        window.selectWeapon = function(w) {
            if(!player) return;
            // Check unlocks in SP
            if(!isMultiplayer) {
                const unlocks = SPManager.levels.getUnlocks(SPManager.level);
                if(!unlocks.includes(w)) return;
            }
            player.currentWeapon = w;
            updateHUD();
        };

        function startSinglePlayerSetup() {
            SPManager.init();
        }

        function showMultiplayerLobby() {
            mode = 'mp';
            isMultiplayer = true;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('mp-lobby-screen').classList.remove('hidden');
            connectSocket();
            setTeam(1);
        }

        /* --- GAME LOGIC --- */
        function generateTerrain() {
            terrainPoints = [];
            for(let x=0; x<=TERRAIN_WIDTH; x+=SEGMENT_SIZE) {
                let y = WORLD_HEIGHT * 0.8;
                y += Math.sin(x*0.002)*150 + Math.sin(x*0.01)*50;
                terrainPoints.push({x, y});
            }
        }
        function getTerrainHeight(x) {
            if(x<0||x>TERRAIN_WIDTH) return WORLD_HEIGHT+1000;
            const i = Math.floor(x/SEGMENT_SIZE);
            if(i>=terrainPoints.length-1) return terrainPoints[terrainPoints.length-1].y;
            const p1 = terrainPoints[i]; const p2 = terrainPoints[i+1];
            return p1.y + (p2.y-p1.y) * ((x-p1.x)/SEGMENT_SIZE);
        }
        
        function updateHUD() {
            if(!player) return;
            document.getElementById('hud-hp').style.width = (player.hp/player.maxHp*100) + "%";
            document.getElementById('hud-hp-text').innerText = Math.ceil(player.hp) + "%";
            document.getElementById('hud-lives').innerText = player.lives;
            
            ['standard', 'scatter', 'laser', 'seeker', 'nuke', 'builder'].forEach(w => {
                const btn = document.getElementById('btn-'+w);
                const am = document.getElementById('ammo-'+w);
                am.innerText = player.ammo[w] === Infinity ? '∞' : player.ammo[w];
                if(player.currentWeapon === w) btn.classList.add('active'); else btn.classList.remove('active');
            });
            if(isCharging) document.getElementById('hud-power').style.width = Math.min((Date.now()-mousePressedTime)/1000*100, 100) + "%";
        }
        
        function log(msg) {
            const d = document.getElementById('battle-log');
            const e = document.createElement('div'); e.className='log-entry'; e.innerText="> "+msg;
            d.appendChild(e); if(d.children.length>5) d.removeChild(d.firstChild);
        }
        function createExplosion(x,y,type) {
            for(let i=0;i<(type==='nuke'?50:15);i++) particles.push(new Particle(x,y,type==='nuke'?'#ff0':'#f60'));
            screenShake = type==='nuke'?20:5;
        }
        const dist = (x1,y1,x2,y2) => Math.sqrt((x2-x1)**2+(y2-y1)**2);

        /* --- MULTIPLAYER SPECIFIC --- */
        let selectedTeam = 1;
        function setTeam(t) {
            selectedTeam = t;
            document.getElementById('btn-team-1').style.background = t===1 ? 'rgba(0,255,255,0.2)' : '';
            document.getElementById('btn-team-2').style.background = t===2 ? 'rgba(255,0,0,0.2)' : '';
        }
        function connectSocket() {
            if(socket) return;
            socket = io(window.location.origin);
            socket.on('roomList', rooms => {
                const c = document.getElementById('room-list-container'); c.innerHTML = '';
                rooms.forEach(r => {
                    const d = document.createElement('div'); d.className='room-item';
                    d.innerHTML = `<span>${r.name}</span><span>${r.blue}v${r.red}</span>`;
                    d.onclick = () => document.getElementById('inp-room').value = r.name;
                    c.appendChild(d);
                });
            });
            socket.on('init', data => {
                player = new Tank(true, data.team, data.id);
                player.name = document.getElementById('inp-name').value || "YOU";
                player.lives = 5; // MP standard lives
                // Restore infinite Standard ammo for MP only
                player.ammo.standard = Infinity;
                
                generateTerrain();
                if(data.dynamicPlatforms) data.dynamicPlatforms.forEach(p => platforms.push(p));
                if(data.gameStatus === 'playing') startGameClient();
                else updateLobbyStatus();
            });
            socket.on('stateUpdate', players => {
                for(let id in players) {
                    if(id !== socket.id) {
                        if(!remotePlayers[id]) {
                            remotePlayers[id] = new Tank(false, players[id].team, id);
                            remotePlayers[id].name = players[id].name || "ENEMY";
                        }
                        const p = remotePlayers[id];
                        p.targetX = players[id].x; p.targetY = players[id].y;
                        p.turretAngle = players[id].turretAngle;
                        p.hp = players[id].hp; p.dead = players[id].dead;
                    }
                }
            });
            socket.on('playerFired', d => { if(remotePlayers[d.id]) remotePlayers[d.id].fire(d.power); });
            socket.on('playerJoined', d => { log(d.name + " JOINED"); updateLobbyStatus(); });
            socket.on('gameStarted', startGameClient);
            socket.on('playerDied', d => { 
                if(d.id === socket.id) { player.dead=true; player.lives=d.lives; }
                else if(remotePlayers[d.id]) { remotePlayers[d.id].dead=true; remotePlayers[d.id].lives=d.lives; }
                log("UNIT DESTROYED");
            });
            socket.on('playerRespawn', d => {
                const t = d.id===socket.id ? player : remotePlayers[d.id];
                if(t) { t.dead=false; t.hp=100; t.x=d.x; t.y=d.y; }
            });
            socket.on('gameOver', d => {
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('go-score').innerText = d.winner + " WINS";
            });
            // ... (Other MP handlers like crates/platforms would go here, reusing SP logic classes)
        }
        function joinGame() {
            socket.emit('createOrJoin', { room: document.getElementById('inp-room').value||"A", name: document.getElementById('inp-name').value, team: selectedTeam });
            document.getElementById('join-area').classList.add('hidden');
            document.getElementById('waiting-area').classList.remove('hidden');
        }
        function requestStart() { socket.emit('requestStartGame'); }
        function startGameClient() {
            document.getElementById('mp-lobby-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            document.getElementById('scoreboard').style.display = 'block';
        }
        function updateLobbyStatus() {
            document.getElementById('waiting-player-list').innerText = `Pilots: ${Object.keys(remotePlayers).length+1}`;
            if(player && player.id === socket.id) document.getElementById('btn-start-game').classList.remove('hidden');
        }

        /* --- RENDER LOOP --- */
        function animate() {
            requestAnimationFrame(animate);
            if(mode === 'menu') {
                // Intro cam drift
                camera.x+=1; if(camera.x>5000) camera.x=0;
                ctx.fillStyle = '#050510'; ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.save(); ctx.translate(-camera.x, -camera.y);
                drawTerrain(ctx);
                ctx.restore();
                return;
            }

            if(player && !player.dead) {
                let tx = player.x - canvas.width/2/camera.zoom;
                let ty = player.y - canvas.height/2/camera.zoom;
                camera.x += (tx - camera.x) * 0.1;
                camera.y += (ty - camera.y) * 0.1;
            }
            if(screenShake>0) { camera.x += (Math.random()-0.5)*screenShake; camera.y += (Math.random()-0.5)*screenShake; screenShake*=0.9; }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);

            // Sky
            const grd = ctx.createLinearGradient(0,0,0,WORLD_HEIGHT);
            grd.addColorStop(0,"#000510"); grd.addColorStop(1,"#101025");
            ctx.fillStyle = grd; ctx.fillRect(camera.x, camera.y, canvas.width/camera.zoom, canvas.height/camera.zoom);

            drawTerrain(ctx);
            
            if(player) player.update();
            if(player) player.draw(ctx);
            
            Object.values(remotePlayers).forEach(p => { p.update(); p.draw(ctx); });
            bots.forEach(b => { b.update(); b.draw(ctx); });
            
            projectiles.forEach(p => { p.update(); p.draw(ctx); });
            projectiles = projectiles.filter(p => p.active);
            
            crates.forEach(c => { c.update(); c.draw(ctx); });
            particles.forEach(p => { p.update(); p.draw(ctx); });
            particles = particles.filter(p => p.life>0);
            
            floatingTexts.forEach(t => { t.update(); t.draw(ctx); });
            floatingTexts = floatingTexts.filter(t => t.life>0);

            // Drawing Tool visual
            if(isDrawing) {
                const mx = mousePos.x/camera.zoom+camera.x; const my = mousePos.y/camera.zoom+camera.y;
                ctx.strokeStyle = '#f0f'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(drawStart.x, drawStart.y); ctx.lineTo(mx, my); ctx.stroke();
            }

            ctx.restore();
            drawMinimap();
        }

        function drawTerrain(ctx) {
            ctx.fillStyle = '#001520'; ctx.beginPath();
            ctx.moveTo(0, WORLD_HEIGHT+1000);
            terrainPoints.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.lineTo(TERRAIN_WIDTH, WORLD_HEIGHT+1000); ctx.fill();
            ctx.strokeStyle = '#0ff'; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.stroke();
            
            platforms.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle*Math.PI/180);
                ctx.fillStyle = `rgba(0,0,50,${p.hp/p.maxHp})`; ctx.strokeStyle = '#0ff';
                ctx.fillRect(0,0,p.width,p.height); ctx.strokeRect(0,0,p.width,p.height);
                ctx.restore();
            });
        }
        
        function drawMinimap() {
            minimapCtx.fillStyle = '#000'; minimapCtx.fillRect(0,0,300,180);
            const sx = 300/TERRAIN_WIDTH; const sy = 180/WORLD_HEIGHT;
            minimapCtx.strokeStyle = '#055'; minimapCtx.beginPath();
            terrainPoints.forEach(p => { if(p.x%100<20) minimapCtx.lineTo(p.x*sx, p.y*sy); });
            minimapCtx.stroke();
            if(player) { minimapCtx.fillStyle='#0ff'; minimapCtx.fillRect(player.x*sx, player.y*sy, 4, 4); }
            bots.forEach(b => { if(!b.dead){ minimapCtx.fillStyle='#f00'; minimapCtx.fillRect(b.x*sx, b.y*sy, 4, 4); }});
            crates.forEach(c => { minimapCtx.fillStyle='#0f0'; minimapCtx.fillRect(c.x*sx, c.y*sy, 3, 3); });
        }

        init();
    </script>
</body>
</html>